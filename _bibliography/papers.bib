@inproceedings{kop_et_al:LIPIcs.FSCD.2021.31,
  abbr      = {conf},
  author    = {Kop, Cynthia and Vale, Deivid},
  title     = {{Tuple Interpretations for Higher-Order Complexity}},
  booktitle = {6th International Conference on Formal Structures for Computation and Deduction (FSCD 2021)},
  pages     = {31:1--31:22},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-191-7},
  issn      = {1868-8969},
  year      = {2021},
  volume    = {195},
  editor    = {Kobayashi, Naoki},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/opus/volltexte/2021/14269},
  urn       = {urn:nbn:de:0030-drops-142692},
  doi       = {10.4230/LIPIcs.FSCD.2021.31},
  arxiv     = {2105.01112},
  selected = true
}

@inproceedings{DBLP:journals/corr/abs-2112-05715,
  abbr       = {short},
  author     = {Deivid Vale and
                Niels van der Weide},
  title      = {Formalizing Higher-Order Termination in Coq},
  booktitle  = {Proc. 17th International Workshop on Termination},
  year       = {2021},
  url        = {https://arxiv.org/abs/2112.05715},
  eprinttype = {arXiv},
  arxiv      = {2112.05715},
  url        = {http://costa.fdi.ucm.es/wst2021/WST2021_proceedings.pdf},
  timestamp  = {Tue, 14 Dec 2021 14:21:31 +0100},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2112-05715.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org},
  website    = {https://github.com/nmvdw/Nijn},
  abstract   = {We describe a formalization of higher-order rewriting theory and formally prove that an AFS is strongly normalizing if it can be interpreted in a well-founded domain. To do so, we use Coq, which is a proof assistant based on dependent type theory. Using this formalization, one can implement several termination techniques, like the interpretation method or dependency pairs, and prove their correctness. Those implementations can then be extracted to OCaml, which results in a verified termination checker.
                }
}


@inproceedings{10.1007/978-3-030-71995-1_2,
  abbr      = {conf},
  author    = {Ayala-Rinc{\'o}n, Mauricio
               and Fern{\'a}ndez, Maribel
               and Nantes-Sobrinho, Daniele
               and Vale, Deivid},
  editor    = {Kiefer, Stefan
               and Tasson, Christine},
  title     = {Nominal Equational Problems},
  booktitle = {Foundations of Software Science and Computation Structures},
  year      = {2021},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {22--41},
  selected = true
}

@article{AYALARINCON20203,
  abbr     = {conf},
  title    = {On Solving Nominal Disunification Constraints},
  journal  = {Electronic Notes in Theoretical Computer Science},
  volume   = {348},
  pages    = {3-22},
  year     = {2020},
  issn     = {1571-0661},
  doi      = {10.1016/j.entcs.2020.02.002},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066120300025},
  author   = {Mauricio Ayala-Rincón and Maribel Fernández and Daniele Nantes-Sobrinho and Deivid Vale},
  keywords = {Nominal Logic, Nominal Semantics, Unification, Disunification}
}

@mastersthesis{deivid:2019,
  abbr        = {master thesis},
  author      = {Deivid Vale},
  school      = {University of Brasilia},
  title       = {On Solving Nominal Disunification Problems},
  year        = {2019},
  abstract    = {
                 My master thesis's research was all about solving nominal disunification problems.
                 The nominal setting is a very nice formalism to deal with alpha-equivalence.
                 It's also very usefull to deal with name-scoping in programming languages and to have a formal proof that under suitable context assumptions I can call all my friends by just 'José' :)
                 },
  pdf         = {master_thesis.pdf},
  bibtex_show = true
}
